{"version":3,"sources":["zprint/optionfn.cljc"],"mappings":"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","names":["var_args","G__50727","zprint.optionfn/rodfn","js/Error","rod-options","options","len","sexpr","zprint.optionfn.rodfn","multi-arity-nl?","cljs.core.get","fn-name?","cljs.core/Symbol","cljs.core/second","docstring?","cljs.core.nth","multi-arity?","cljs.core/vector?","nl-count","and__5041__auto__","option-map","cljs.core.assoc","G__50735","zprint.optionfn/meta-base-fn","opts","n","exprs","cljs.core/meta","zfn-map","zloc-seq-nc","G__50740","G__50741","fexpr__50739","cljs.core/identity","meta-zloc","meta-seq","fexpr__50742","cljs.core._EQ_","G__50744","fexpr__50743","cljs.core/map?","cljs.core/count","cljs.core/keys"],"sourcesContent":["(ns ^:no-doc zprint.optionfn\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer\n               [dbg dbg-s dbg-pr dbg-s-pr dbg-form dbg-print zfuture]]]])\n  (:require #?@(:clj [[zprint.macros :refer\n                       [dbg-pr dbg-s-pr dbg dbg-s dbg-form dbg-print zfuture]]])\n            [zprint.util :refer [column-alignment cumulative-alignment]]))\n\n;;\n;; Contains functions which can be called with {:option-fn <fn>} to produce\n;; a new options map.  Option-fns which produce a \"guide\" are in guide.cljc.\n;; The optionfns here are called the same way, but just produce a basic\n;; option map.\n;;\n\n(defn rodfn\n  \"Given a structure which starts with defn or fn format it using the\n  'rules of defn'.\"\n  ([] \"rodfn\")\n  ; If you call an option-fn with partial because it has its own options map,\n  ; the \"no-argument\" arity must include the options map!\n  ([rod-options] \"rodfn\")\n  ; Since we have released this before, we will also allow it to be called\n  ; without rod-options (since this is a drop-in replacement for rodguide).\n  ([options len sexpr] (rodfn {} options len sexpr))\n  ([rod-options options len sexpr]\n   (let [multi-arity-nl? (get rod-options :multi-arity-nl? true)\n         fn-name? (symbol? (second sexpr))\n         docstring? (string? (nth sexpr (if fn-name? 2 1)))\n         multi-arity? (not (vector? (nth sexpr\n                                         (cond (and fn-name? docstring?) 3\n                                               (or fn-name? docstring?) 2\n                                               :else 1))))\n         nl-count (cond (and multi-arity? multi-arity-nl? docstring?) [1 2]\n                        (and multi-arity? multi-arity-nl?) [2]\n                        :else [1])\n         option-map {:list {:nl-count nl-count},\n                     :next-inner {:list {:option-fn nil}},\n                     :next-inner-restore [[:list :nl-count]]}\n         option-map (cond (and fn-name? docstring?)\n                            (assoc option-map :fn-style :arg1-force-nl-body)\n                          (and fn-name? (not multi-arity?))\n                            (assoc option-map :fn-style :arg2-force-nl-body)\n                          fn-name? (assoc option-map\n                                     :fn-style :arg1-force-nl-body)\n                          (not multi-arity?) (assoc option-map\n                                               :fn-style :arg1-force-nl-body)\n                          :else (assoc option-map :fn-style :flow-body))]\n     (if multi-arity?\n       (assoc option-map\n         :next-inner {:list {:option-fn nil},\n                      :fn-map {:vector :force-nl},\n                      :next-inner-restore [[:fn-map :vector]]})\n       option-map))))\n\n; Use this to use the above:\n;\n; (czprint rod4\n;    {:parse-string? true\n;     :fn-map {\"defn\" [:none {:list {:option-fn rodfn}}]}})\n\n(defn meta-base-fn\n  \"Look at a list, and if it has metadata, then based on the kind of\n  metadata, try to do it differently than the normal metadata output.\"\n  ([] \"meta-base-fn\")\n  ([opts n exprs]\n   (when (meta (second exprs))\n     #_(println (meta (second exprs)))\n     (let [zfn-map (:zfn-map opts)\n           zloc-seq-nc ((:zmap-no-comment zfn-map) identity (:zloc opts))\n           meta-zloc (second zloc-seq-nc)\n           #_(println \"tag:\" ((:ztag zfn-map) meta))\n           meta-seq ((:zmap-no-comment zfn-map) identity meta-zloc)\n           #_(println \"count meta-seq:\" (count meta-seq)\n                      \"meta-seq:\" (map (:zstring zfn-map) meta-seq)\n                      \"meta-seq-tag:\" (map (:ztag zfn-map) meta-seq))]\n       (if (= :meta ((:ztag zfn-map) (second meta-seq)))\n         ; Figure out next-inner restore\n         nil\n         {:meta {:split? true},\n          :list {:hang-expand 0},\n          :fn-style (if (and (map? (meta (second exprs)))\n                             (> (count (keys (meta (second exprs)))) 1))\n                      :arg1-body\n                      :arg2),\n          :next-inner-restore [[:list :hang-expand]]})))))\n\n"]}