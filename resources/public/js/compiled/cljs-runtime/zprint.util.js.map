{"version":3,"sources":["zprint/util.cljc"],"mappings":"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","names":["p__50260","vec__50261","cljs.core.nth","zprint.util/dissoc-two","m","k1","k2","cljs.core.assoc","cljs.core.dissoc","cljs.core.get","zprint.util/local-abs","n","var_args","G__50265","zprint.util/size","js/Error","sexpr","no-string-adj?","s","clojure.string/starts-with?","clojure.string/replace","s-count","cljs.core/not","zprint.util.size","zprint.util/median","coll","sorted-coll","cljs.core.sort","len","cljs.core/count","middle","cljs.core/odd?","lower","lower-middle","upper-middle","zprint.util/mean","cljs.core/empty?","cljs.core.apply","cljs.core/+","zprint.util/percent-gt-n","count-gt","cljs.core.reduce","cnt","percentage","zprint.util/variance","cljs.core.remove","cljs.core/nil?","mean","dev-from-mean","cljs.core.mapv","cljs.core.partial","cljs.core/-","sq-dev-from-mean","p1__50290#","variance","zprint.util/find-max","indicies","p__50309","vec__50310","max-so-far","index","cljs.core._EQ_","cljs.core.conj","zprint.util/remove-indicies","cljs.core/assoc","cljs.core.interleave","cljs.core.repeat","zprint.util/remove-max-not-half","coll-vec","vec__50335","max-number","length","zprint.util/remove-indicies-from-columns","columns","vec__50349","beginning","end","cljs.core/split-at","cljs.core.into","new-end","zprint.util/count-non-nil","x","zprint.util/column-width-variance","max-variance","column","beginning-variance","row-count","cljs.core/first","vec__50375","first-indicies","first-column-wo-max","first-variance","vec__50380","second-indicies","second-column-wo-max","second-variance","zprint.util/size-and-extend","last-good-col","out","cljs.core/next","G__50408","zprint.util/size-and-extend-butlast","seq-of-seqs","max-len","cljs.core/max","cljs.core.map","x__5131__auto__","y__5132__auto__","seq-of-sizes","zprint.util.size_and_extend_butlast","G__50428","zprint.util/create-columns","number-of-columns","transpose","cljs.core/mapv","cljs.core/vector","zprint.util.create_columns","G__50449","zprint.util/column-alignment","max-width-vec","cljs.core/second","p__50455","vec__50458","vec__50462","max-width","new-columns","cljs.core/reduced","cljs.core.range","zprint.util.column_alignment","zprint.util/cumulative-alignment","p__50473","vec__50475","current-width","cumulative-widths","column-max-width","this-alignment"],"sourcesContent":["(ns ^:no-doc zprint.util\n  (:require [clojure.string :as s]))\n\n(defn dissoc-two\n  \"Do a simple dissoc-in for two levels.  Does not remove the\n  second map if it is empty.\"\n  [m [k1 k2]]\n  (assoc m k1 (dissoc (get m k1) k2)))\n\n(defn local-abs\n  \"Return the absolute value of a number.\"\n  [n]\n  (if (neg? n) (- n) n))\n\n(defn size\n  \"Return the size of an sexpr, essentially the number of characters\n  in its string representation.  If the sexpr is already a string,\n  return the number of characters in the string plus 2 to account\n  for the double quotes, unless no-string-adj? is non-nil.  In that\n  case, simply return the character count of the string.  If sexpr\n  is nil, return nil.\"\n  ([sexpr no-string-adj?]\n   (when sexpr\n     #_(prn \"size:\" sexpr \"string?\" (string? sexpr))\n     (let [s (str sexpr)\n           s (cond (clojure.string/starts-with? s \":zprint.core/\")\n                     (clojure.string/replace s \":zprint.core/\" \"::\")\n                   (clojure.string/starts-with? s \":clojure.core/\")\n                     (clojure.string/replace s \":clojure.core/\" \"::\")\n                   :else s)\n           s-count (count s)]\n       (if (and (not no-string-adj?) (string? sexpr)) (+ s-count 2) s-count))))\n  ([sexpr] (size sexpr nil)))\n\n(defn median\n  \"Find the median of a series of numbers.\"\n  [coll]\n  (let [sorted-coll (sort coll)\n        len (count coll)\n        middle (/ len 2)]\n    (if (odd? len)\n      (nth sorted-coll middle)\n      (let [lower (dec middle)\n            lower-middle (nth sorted-coll lower)\n            upper-middle (nth sorted-coll middle)]\n        (/ (+ lower-middle upper-middle) 2)))))\n\n(defn mean\n  \"Find the mean of a series of numbers.\"\n  [coll]\n  (when (not (empty? coll)) (/ (apply + coll) (count coll))))\n\n(defn percent-gt-n\n  \"Return the percentage of numbers greater than n.\"\n  [n coll]\n  (when (not (empty? coll))\n    (let [count-gt (reduce (fn [cnt m] (if (> m n) (inc cnt) cnt)) 0 coll)\n          percentage (int (* (/ count-gt (count coll)) 100))]\n      percentage)))\n\n(defn variance\n  \"Return the variance of a sequence of numbers. Ignore nil values.\n  Return the variance or nil if there are no numbers.\"\n  [coll]\n  (let [coll (remove nil? coll)\n        #_(println \"coll:\" coll \"len:\" (count coll))\n        len (count coll)]\n    (when (not (zero? len))\n      (let [mean (/ (apply + coll) len)\n            dev-from-mean (mapv (partial - mean) coll)\n            sq-dev-from-mean (mapv #(* % %) dev-from-mean)\n            variance (int (/ (apply + sq-dev-from-mean) len))]\n        #_(println \"variance:\" variance)\n        variance))))\n\n(defn find-max\n  \"Given a sequence of numbers, return the indices of all of the\n  numbers that are equal to the maximum number.  Returns: \n  [max-number [indicies-of-max-number] length-of-sequence]\"\n  [coll]\n  (let [indicies (reduce (fn [[max-so-far indicies index] n]\n                           (cond (nil? n) [max-so-far indicies (inc index)]\n                                 (> n max-so-far) [n [index] (inc index)]\n                                 (= n max-so-far) [max-so-far\n                                                   (conj indicies index)\n                                                   (inc index)]\n                                 :else [max-so-far indicies (inc index)]))\n                   [0 [] 0]\n                   coll)]\n    indicies))\n\n(defn remove-indicies\n  \"Given a vector, set specific indicies to nil.\"\n  [indicies coll]\n  (if indicies (apply assoc coll (interleave indicies (repeat nil))) coll))\n\n(defn remove-max-not-half\n  \"Given a vector of numbers, remove every instance of the maximum number \n  from the vector and replace it with nil, unless it would remove more \n  than half of the numbers in the vector, in which case return the vector\n  unchanged. Returns: [indicies-removed vector-with-max-removed]\"\n  [coll-vec]\n  (let [[max-number indicies length] (find-max coll-vec)]\n    (if (> (count indicies) (/ length 2))\n      [nil coll-vec]\n      [indicies (remove-indicies indicies coll-vec)])))\n\n(defn remove-indicies-from-columns\n  \"Given a vector of indicies and a vector of vectors (columns), remove \n  the specified indicies from the columns by replacing them with nil, starting\n  at the vector specified by the index.\"\n  [index indicies columns]\n  (if (< index (count columns))\n    (let [[beginning end] (split-at index columns)\n          beginning (into [] beginning)\n          end (into [] end)\n          new-end (mapv (partial remove-indicies indicies) end)]\n      (into beginning new-end))\n    columns))\n\n(defn count-non-nil\n  \"Count the non-nil items in a sequence.\"\n  [coll]\n  (reduce (fn [cnt x] (if (nil? x) cnt (inc cnt))) 0 coll))\n\n(defn column-width-variance\n  \"Given a vector of vectors, where each vector represents the sizes\n  in a column, find the variance of the column, and if it is too high\n  remove the largest and then second largest values to see if we can\n  get it low enough for alignment.  If yes, return the alignment and the\n  new vector of vectors (where the rows that were not considered for the\n  successful variance calculation have been removed from all (inc index)\n  columns).  If no, return nil and the unchanged vector of vectors. \n  Returns: [max-width-or-nil columns]\"\n  [max-variance columns index]\n  (if (>= index (count columns))\n    [nil columns]\n    (let [column (nth columns index)\n          #_(println \"column:\" column \"index:\" index)\n          beginning-variance (variance column)\n          row-count (count-non-nil column)]\n      #_(println \"beginning-variance:\" beginning-variance)\n      (cond\n        (nil? beginning-variance) [nil columns]\n        (> max-variance beginning-variance) [(first (find-max column)) columns]\n        ; Unless we have at least 3 rows, we aren't removing anything to\n        ; try and get the variance to work!\n        (> row-count 2)\n          (let [[first-indicies first-column-wo-max] (remove-max-not-half\n                                                       column)\n                #_(println \"column:\" column)\n                #_(println \"first-column-wo-max:\" first-column-wo-max)\n                first-variance (variance first-column-wo-max)]\n            (cond (nil? first-variance) [nil columns]\n                  (> max-variance first-variance)\n                    [(first (find-max first-column-wo-max))\n                     (remove-indicies-from-columns (inc index)\n                                                   first-indicies\n                                                   columns)]\n                  :else\n                    (let [[second-indicies second-column-wo-max]\n                            (remove-max-not-half first-column-wo-max)\n                          second-variance (variance second-column-wo-max)]\n                      (cond (nil? second-variance) [nil columns]\n                            ; Have we removed half of the rows\n                            ; between the first and second rounds?\n                            (>= (+ (count first-indicies)\n                                   (count second-indicies))\n                                (/ row-count 2))\n                              [nil columns]\n                            (> max-variance second-variance)\n                              [(first (find-max second-column-wo-max))\n                               (remove-indicies-from-columns\n                                 (inc index)\n                                 (into first-indicies second-indicies)\n                                 columns)]\n                            :else [nil columns]))))\n        :else [nil columns]))))\n\n(defn size-and-extend\n  \"Given a seq and a length, return a vector which contains the\n  size of every element in the seq and is the length specified.  If\n  the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  If the length is less than the\n  length of the input seq, then skip the remaining elements.  If\n  the length is greater than the length of the input seq, fill out\n  the missing elements with nils, and ensure that the last element\n  is replaced by a nil (to avoid influencing the spacing of a column\n  that it doesn't have).\"\n  [length no-string-adj? coll]\n  (let [last-good-col (dec (count coll))]\n    (loop [coll coll\n           index 0\n           out []]\n      (if (>= index length)\n        out\n        (recur (next coll)\n               (inc index)\n               (conj out\n                     (if (>= index last-good-col)\n                       nil\n                       (size (first coll) no-string-adj?))))))))\n\n(defn size-and-extend-butlast\n  \"Given a sequence of seqs, produce a new sequence of seqs where\n  each element in the seq is replaced by the size of that element.\n  If the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  Do this for all of the elements in\n  every seq but the last.  In addition, for every seq that is shorter\n  than the longest one, fill out the missing elements with nils.\"\n  ([seq-of-seqs max-len no-string-adj?]\n   #_(println \"size-and-extend-butlast: seq-of-seqs\" seq-of-seqs)\n   #_(println \"no-string-adj?\" no-string-adj?)\n   (let [len (dec (apply max (map count seq-of-seqs)))\n         len (if max-len (min max-len len) len)\n         seq-of-sizes (mapv (partial size-and-extend len no-string-adj?)\n                        seq-of-seqs)]\n     seq-of-sizes))\n  ([seq-of-seqs] (size-and-extend-butlast seq-of-seqs nil nil))\n  ([seq-of-seqs max-len] (size-and-extend-butlast seq-of-seqs max-len nil)))\n\n(defn create-columns\n  \"Given a seq of seqs, create a vector of vectors where every\n  internal vector contains a series of integers representing the\n  width of the element in that column across all of the seqs.  The\n  width for the elements is their string length. Note that the\n  length of actual strings is increased by two to account for the\n  double quotes unless no-string-adj? is non-nil, in which case\n  these routines assume that was already handled.  The various input\n  seqs do not have to be the same length, and there will be as many\n  columns as one less than the count of elements in the longest seq\n  (or number-of-columns if it is specified and less than the count\n  of the elements in the longest seq).  For seqs which do not extend\n  to the maximum length, their positions in the column vectors will\n  be filled with nil.\"\n  ([seq-of-seqs number-of-columns no-string-adj?]\n   (let [seq-of-sizes (size-and-extend-butlast seq-of-seqs\n                                               number-of-columns\n                                               no-string-adj?)\n         transpose (apply mapv vector seq-of-sizes)]\n     transpose))\n  ([seq-of-seqs] (create-columns seq-of-seqs nil nil))\n  ([seq-of-seqs number-of-columns]\n   (create-columns seq-of-seqs number-of-columns nil)))\n\n(defn column-alignment\n  \"Given a seq-of-seqs which contain elements to justify, return a\n  vector with the size of the maximum element in each column that\n  should be used to justify the next column.  Note that the length\n  of actual strings is increased by two to account for the double\n  quotes unless no-string-adj? is non-nil, in which case these\n  routines assume that was already handled.  If number-of-columns\n  is given, only justify that many columns, else justify all but\n  the last. Note that if the max-variance is exceeded after having\n  skipped the largest and second largest in a column, then the return\n  is nil, signifying that justification is not possible.\"\n  ([max-variance seq-of-seqs number-of-columns no-string-adj?]\n   (let [columns (create-columns seq-of-seqs number-of-columns no-string-adj?)\n         #_(println \"column count:\" (count columns))\n         max-width-vec\n           (second\n             (reduce\n               (fn [[columns max-width-vec] index]\n                 (let [[max-width new-columns]\n                         (column-width-variance max-variance columns index)]\n                   #_(println \"max-width:\" max-width)\n                   (if max-width\n                     [new-columns (conj max-width-vec max-width)]\n                     ; If we fail, then fail completely, don't return a\n                     ; short max-width-vec!  Issue #212.\n                     (reduced [columns nil]))))\n               [columns []]\n               (range (count columns))))]\n     max-width-vec))\n  ([max-variance seq-of-seqs]\n   (column-alignment max-variance seq-of-seqs nil nil))\n  ([max-variance seq-of-seqs number-of-columns]\n   (column-alignment max-variance seq-of-seqs number-of-columns nil)))\n\n(defn cumulative-alignment\n  \"Given a vector of max-widths from column-alignment, produce a vector\n  of the cumulative alignment positions for the second through nth columns.\"\n  [max-width-vec]\n  (second\n    (reduce (fn [[current-width cumulative-widths] column-max-width]\n              (let [this-alignment (+ current-width (inc column-max-width))]\n                [this-alignment (conj cumulative-widths this-alignment)]))\n      [0 []]\n      max-width-vec)))\n\n"]}